<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Code Diff - Compare Two Text Files Online</title>

    <style>
      :root {
        --bg: #f5f7fb;
        --card: #ffffff;
        --border: #e5e7eb;
        --text: #111827;
        --muted: #6b7280;
        --brand: #7b38d8;
        --brand2: #6a2ec4;
        --shadow: 0 2px 10px rgba(17, 24, 39, 0.06);

        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;

        --add: rgba(233, 249, 238, 0.992);
        --del: rgb(255, 236, 236);
        --chg: rgb(255, 247, 230);
        --miss: rgb(243, 244, 246);

        --addWord: #bdf0cc;
        --delWord: #ffbfbf;
        --radius: 10px;
      }

      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: var(--sans);
        background: var(--bg);
        color: var(--text);
      }
      .wrap {
        margin: 50px 5%;
        padding: 20px 14px 28px;
      }
      h1 {
        font-size: 28px;
        margin: 6px 0 14px;
        font-weight: 800;
        letter-spacing: 0.2px;
      }

      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
      }

      .top-controls {
        position: sticky;
        top: 0;
        z-index: 40;
        background: var(--card);

        display: grid;
        /* IMPORTANT: use --sideW so center stays true even when legend appears on right */
        grid-template-columns: var(--sideW, 1fr) auto var(--sideW, 1fr);
        align-items: center;
        gap: 10px;
        padding: 14px;
        border-bottom: 1px solid var(--border);
      }

      /* left group wraps */
      .tc-left {
        display: flex;
        flex-wrap: wrap; /* <-- add this */
        gap: 10px;
        align-items: center;
        min-width: 0;
      }

      /* center */
      .tc-center {
        justify-self: center;
      }

      /* right group: holds legend when docked */
      .tc-right {
        justify-self: end;
        min-width: 1px;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: 10px;
      }

      label {
        font-size: 12px;
        color: var(--muted);
        display: flex;
        gap: 6px;
        align-items: center;
        user-select: none;
        white-space: nowrap;
      }
      select,
      .btn {
        height: 34px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #fff;
        color: var(--text);
        font-size: 13px;
        padding: 0 10px;
      }

      .btn {
        cursor: pointer;
        font-weight: 700;
        border-color: transparent;
        background: var(--brand);
        color: #fff;
      }
      .btn:hover {
        background: var(--brand2);
      }
      .btn.secondary {
        background: #fff;
        border-color: var(--border);
        color: var(--text);
      }
      .btn.secondary:hover {
        background: #fafafa;
      }

      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        padding: 14px;
      }
      .pane-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-bottom: none;
        border-radius: 8px 8px 0 0;
        background: #fafafa;
        font-size: 13px;
        font-weight: 700;
      }
      .pane-head div {
        display: flex;
        gap: 5px;
        align-items: center;
      }
      .pane-sub {
        font-size: 12px;
        font-weight: 600;
        color: var(--muted);
      }

      textarea {
        width: 100%;
        height: 240px;
        border: 1px solid var(--border);
        border-radius: 0 0 8px 8px;
        padding: 10px 12px;
        font-family: var(--mono);
        font-size: 13px;
        line-height: 1.45;
        resize: vertical;
        outline: none;
      }
      textarea:focus {
        border-color: rgba(123, 56, 216, 0.45);
        box-shadow: 0 0 0 3px rgba(123, 56, 216, 0.12);
      }
      textarea.wrapText {
        white-space: pre-wrap;
        word-break: break-word;
      }

      .out-head {
        padding: 14px;
        border-top: 1px solid var(--border);
        border-bottom: 1px solid var(--border);
        background: var(--card);
      }

      body.legend-docked .out-head {
        height: 0;
        padding: 0;
        border: 0;
        overflow: hidden;
      }

      .legend {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        font-size: 12px;
        color: var(--muted);
      }
      .leg {
        display: inline-flex;
        gap: 6px;
        align-items: center;
        padding: 6px 10px;
        border: 1px solid var(--border);
        border-radius: 999px;
        background: #fff;
      }
      .sq {
        width: 10px;
        height: 10px;
        border-radius: 3px;
        border: 1px solid rgba(0, 0, 0, 0.06);
      }
      .sq.add {
        background: var(--add);
      }
      .sq.del {
        background: var(--del);
      }
      .sq.chg {
        background: var(--chg);
      }
      .sq.miss {
        background: var(--miss);
      }

      .out {
        display: grid;
        grid-template-columns: 1fr 1fr;
        min-height: 320px;
      }
      .outPane {
        overflow: auto;
        border-right: 1px solid var(--border);
      }
      .outPane:last-child {
        border-right: none;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        font-family: var(--mono);
        font-size: 12.8px;
        line-height: 1.45;
      }
      td {
        padding: 2px 8px;
        vertical-align: top;
        border-bottom: 1px solid rgba(229, 231, 235, 0.9);
      }
      td.ln {
        width: 1%;
        text-align: right;
        color: var(--muted);
        background: #fafafa;
        border-right: 1px solid var(--border);
        user-select: none;
        position: sticky;
        left: 0;
      }
      td.code {
        white-space: pre;
      }
      .wrapOut td.code {
        white-space: pre-wrap;
        word-break: break-word;
      }
      tr {
        height: 23px;
      }
      tr.add td.code {
        background: var(--add);
      }
      tr.del td.code {
        background: var(--del);
      }
      tr.chg td.code {
        background: var(--chg);
      }
      tr.miss td.code {
        background: var(--miss);
      }

      .wAdd {
        background: var(--addWord);
        border-radius: 3px;
        padding: 0 1px;
      }
      .wDel {
        background: var(--delWord);
        border-radius: 3px;
        padding: 0 1px;
      }

      .foot {
        font-size: 12px;
        color: var(--muted);
        padding: 12px 14px;
      }

      @media (max-width: 980px) {
        .grid,
        .out {
          grid-template-columns: 1fr;
        }
        .outPane {
          border-right: none;
          border-bottom: 1px solid var(--border);
        }
        .outPane:last-child {
          border-bottom: none;
        }
        .top-controls {
          grid-template-columns: min-content min-content;
          justify-items: start;
        }

        /* .tc-center {
          justify-self: start; 
        } */
      }
      @media (max-width: 980px) {
        .grid,
        .out {
          grid-template-columns: 1fr;
        }

        .outPane {
          border-right: none;
          border-bottom: 1px solid var(--border);
        }
        .outPane:last-child {
          border-bottom: none;
        }

        /* KEEP the 3-column layout so Swap stays centered */
        .top-controls {
          grid-template-columns: 1fr auto 1fr;
        }

        /* Allow left controls to wrap instead of shrinking the whole grid */
        .tc-left {
          flex-wrap: wrap;
        }
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <h1>Code Diff</h1>

      <div class="card">
        <div class="top-controls">
          <div class="tc-left">
            <label>
              Compare by
              <select id="mode">
                <option value="lines" selected>Lines</option>
                <option value="words">Words</option>
                <option value="chars">Characters</option>
              </select>
            </label>

            <label
              ><input id="ignoreWs" type="checkbox" /> Ignore whitespace</label
            >
            <label><input id="wrap" type="checkbox" /> Wrap</label>
          </div>

          <div class="tc-center">
            <button class="btn secondary" id="swap">Swap</button>
          </div>

          <div class="tc-right"></div>
        </div>

        <div class="grid">
          <div>
            <div class="pane-head">
              <div>Original</div>
              <div>
                <button class="btn secondary" id="copyL">Copy</button>
                <div class="pane-sub" id="leftInfo">0 lines</div>
              </div>
            </div>
            <textarea id="left" spellcheck="false"></textarea>
          </div>

          <div>
            <div class="pane-head">
              <div>Modified</div>
              <div>
                <button class="btn secondary" id="copyR">Copy</button>
                <div class="pane-sub" id="rightInfo">0 lines</div>
              </div>
            </div>
            <textarea id="right" spellcheck="false"></textarea>
          </div>
        </div>

        <div class="out-head">
          <div id="legend" class="legend">
            <span class="leg"><span class="sq miss"></span>Code Missing</span>
            <span class="leg"><span class="sq add"></span>Code Added</span>
            <span class="leg"><span class="sq chg"></span>Code Changed</span>
            <span class="leg"><span class="sq del"></span>Code Deleted</span>
          </div>
        </div>

        <div class="out" id="outWrap">
          <div class="outPane" id="outLeft"></div>
          <div class="outPane" id="outRight"></div>
        </div>

        <div class="foot">
          Paste code into both boxes â€” diff updates automatically.
        </div>
      </div>
    </div>

    <!-- jsdiff -->
    <script src="https://cdn.jsdelivr.net/npm/diff@5/dist/diff.min.js"></script>

    <script>
      const $ = (id) => document.getElementById(id);

      const leftEl = $("left");
      const rightEl = $("right");
      const outLeft = $("outLeft");
      const outRight = $("outRight");
      const outWrap = $("outWrap");

      const modeEl = $("mode");
      const ignoreWsEl = $("ignoreWs");
      const wrapEl = $("wrap");

      const leftInfo = $("leftInfo");
      const rightInfo = $("rightInfo");

      const STORAGE_KEY = "w3docs-like-code-diff:min:v1";

      function assertDiffLoaded() {
        if (!window.Diff) {
          outLeft.innerHTML =
            "<div style='padding:12px;color:#b91c1c;font-family:system-ui'>Error: diff library not loaded. Check your internet / CDN access.</div>";
          outRight.innerHTML = "";
          return false;
        }
        return true;
      }

      const normalize = (s) =>
        (s ?? "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      const countLines = (s) => normalize(s).split("\n").length;

      function debounce(fn, ms = 200) {
        let t;
        return (...args) => {
          clearTimeout(t);
          t = setTimeout(() => fn(...args), ms);
        };
      }

      function enableScrollSync(a, b) {
        let lock = false;
        function sync(src, dst) {
          if (lock) return;
          lock = true;
          const maxSrc = Math.max(1, src.scrollHeight - src.clientHeight);
          const ratio = src.scrollTop / maxSrc;
          dst.scrollTop = ratio * (dst.scrollHeight - dst.clientHeight);
          dst.scrollLeft = src.scrollLeft;
          lock = false;
        }
        a.addEventListener("scroll", () => sync(a, b), { passive: true });
        b.addEventListener("scroll", () => sync(b, a), { passive: true });
      }

      enableScrollSync(outLeft, outRight); // output sync
      enableScrollSync(leftEl, rightEl); // input sync

      async function copyToClipboard(text) {
        if (navigator.clipboard && window.isSecureContext) {
          await navigator.clipboard.writeText(text);
          return true;
        }
        const ta = document.createElement("textarea");
        ta.value = text;
        ta.style.position = "fixed";
        ta.style.left = "-9999px";
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        const ok = document.execCommand("copy");
        ta.remove();
        return ok;
      }

      function saveState() {
        const state = {
          left: leftEl.value,
          right: rightEl.value,
          mode: modeEl.value,
          ignoreWs: ignoreWsEl.checked,
          wrap: wrapEl.checked,
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      }
      const saveStateDebounced = debounce(saveState, 250);

      function loadState() {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        try {
          const s = JSON.parse(raw);
          leftEl.value = s.left ?? "";
          rightEl.value = s.right ?? "";
          modeEl.value = s.mode ?? "lines";
          ignoreWsEl.checked = !!s.ignoreWs;
          wrapEl.checked = !!s.wrap;
          applyWrap();
          return true;
        } catch {
          return false;
        }
      }

      function applyWrap() {
        leftEl.classList.toggle("wrapText", wrapEl.checked);
        rightEl.classList.toggle("wrapText", wrapEl.checked);
        outWrap.classList.toggle("wrapOut", wrapEl.checked);
      }

      function inlineDiffNodes(leftStr, rightStr, side, mode) {
        const frag = document.createDocumentFragment();
        const parts =
          mode === "chars"
            ? Diff.diffChars(leftStr ?? "", rightStr ?? "")
            : Diff.diffWordsWithSpace(leftStr ?? "", rightStr ?? "");

        for (const p of parts) {
          if ((side === "left" && p.removed) || (side === "right" && p.added)) {
            const span = document.createElement("span");
            span.textContent = p.value;
            span.className = side === "left" ? "wDel" : "wAdd";
            frag.appendChild(span);
          } else if (!p.added && !p.removed) {
            frag.appendChild(document.createTextNode(p.value));
          }
        }
        return frag;
      }

      function partToLines(val) {
        const lines = normalize(val).split("\n");
        if (lines.length && lines[lines.length - 1] === "") lines.pop();
        return lines;
      }

      function buildAlignedRows(oldText, newText, ignoreWhitespace) {
        const parts = Diff.diffLines(normalize(oldText), normalize(newText), {
          ignoreWhitespace: !!ignoreWhitespace,
        });

        const rows = [];
        let oldNo = 1,
          newNo = 1;
        let removedBuf = [];

        const flushRemoved = () => {
          for (const l of removedBuf) {
            rows.push({
              type: "del",
              left: l,
              right: null,
              leftNo: oldNo++,
              rightNo: null,
            });
          }
          removedBuf = [];
        };

        for (const p of parts) {
          const lines = partToLines(p.value);

          if (p.removed) {
            removedBuf.push(...lines);
            continue;
          }

          if (p.added) {
            if (removedBuf.length) {
              const max = Math.max(removedBuf.length, lines.length);
              for (let i = 0; i < max; i++) {
                const l = i < removedBuf.length ? removedBuf[i] : null;
                const r = i < lines.length ? lines[i] : null;
                if (l !== null && r !== null)
                  rows.push({
                    type: "chg",
                    left: l,
                    right: r,
                    leftNo: oldNo++,
                    rightNo: newNo++,
                  });
                else if (l !== null)
                  rows.push({
                    type: "del",
                    left: l,
                    right: null,
                    leftNo: oldNo++,
                    rightNo: null,
                  });
                else if (r !== null)
                  rows.push({
                    type: "add",
                    left: null,
                    right: r,
                    leftNo: null,
                    rightNo: newNo++,
                  });
              }
              removedBuf = [];
            } else {
              for (const r of lines)
                rows.push({
                  type: "add",
                  left: null,
                  right: r,
                  leftNo: null,
                  rightNo: newNo++,
                });
            }
            continue;
          }

          if (removedBuf.length) flushRemoved();
          for (const l of lines)
            rows.push({
              type: "eq",
              left: l,
              right: l,
              leftNo: oldNo++,
              rightNo: newNo++,
            });
        }

        if (removedBuf.length) flushRemoved();
        return rows;
      }

      function makeTable() {
        return document.createElement("table");
      }

      function addRow(table, cls, ln, content) {
        const tr = document.createElement("tr");
        if (cls) tr.className = cls;

        const tdLn = document.createElement("td");
        tdLn.className = "ln";
        tdLn.textContent = ln == null ? "" : String(ln);

        const tdCode = document.createElement("td");
        tdCode.className = "code";
        if (content == null) tdCode.textContent = "";
        else if (typeof content === "string") tdCode.textContent = content;
        else tdCode.appendChild(content);

        tr.appendChild(tdLn);
        tr.appendChild(tdCode);
        table.appendChild(tr);
      }

      function render(rows) {
        const tL = makeTable();
        const tR = makeTable();

        const mode = modeEl.value;

        for (const r of rows) {
          if (r.type === "eq") {
            addRow(tL, "", r.leftNo, r.left);
            addRow(tR, "", r.rightNo, r.right);
          } else if (r.type === "del") {
            addRow(tL, "del", r.leftNo, r.left);
            addRow(tR, "miss", null, "");
          } else if (r.type === "add") {
            addRow(tL, "miss", null, "");
            addRow(tR, "add", r.rightNo, r.right);
          } else if (r.type === "chg") {
            let leftNode = r.left,
              rightNode = r.right;
            if (mode === "words" || mode === "chars") {
              leftNode = inlineDiffNodes(r.left, r.right, "left", mode);
              rightNode = inlineDiffNodes(r.left, r.right, "right", mode);
            }
            addRow(tL, "chg", r.leftNo, leftNode);
            addRow(tR, "chg", r.rightNo, rightNode);
          }
        }

        outLeft.replaceChildren(tL);
        outRight.replaceChildren(tR);
      }

      function renderDiff() {
        if (!assertDiffLoaded()) return;

        const a = leftEl.value;
        const b = rightEl.value;

        leftInfo.textContent = `${countLines(a)} lines`;
        rightInfo.textContent = `${countLines(b)} lines`;

        const rows = buildAlignedRows(a, b, ignoreWsEl.checked);
        render(rows);
      }

      const renderDiffDebounced = debounce(renderDiff, 180);

      function onInput() {
        saveStateDebounced();
        renderDiffDebounced();
      }

      leftEl.addEventListener("input", onInput);
      rightEl.addEventListener("input", onInput);

      modeEl.addEventListener("change", () => {
        saveState();
        renderDiff();
      });
      ignoreWsEl.addEventListener("change", () => {
        saveState();
        renderDiff();
      });
      wrapEl.addEventListener("change", () => {
        applyWrap();
        saveState();
      });

      $("swap").addEventListener("click", () => {
        const tmp = leftEl.value;
        leftEl.value = rightEl.value;
        rightEl.value = tmp;
        saveState();
        renderDiff();
      });

      $("copyL").addEventListener("click", async () => {
        await copyToClipboard(leftEl.value);
      });
      $("copyR").addEventListener("click", async () => {
        await copyToClipboard(rightEl.value);
      });

      // init
      const loaded = loadState();
      if (!loaded) {
        leftEl.value = "Paste a text";
        rightEl.value = "Paste a text";
        applyWrap();
        saveState();
      }
      renderDiff();

      // ---- Dock legend into top-controls right when out-head reaches top ----
      const topControlsEl = document.querySelector(".top-controls");
      const tcLeftEl = document.querySelector(".tc-left");
      const tcRightEl = document.querySelector(".tc-right");
      const outHeadEl = document.querySelector(".out-head");
      const legendEl = document.getElementById("legend");

      // Create a marker right before out-head to detect when we scroll past it
      const marker = document.createElement("div");
      marker.style.height = "1px";
      marker.style.width = "1px";
      outHeadEl.parentNode.insertBefore(marker, outHeadEl);

      let isDocked = false;

      // Keep swap truly centered by forcing left+right columns to have equal width
      function updateSideWidth() {
        // measure after legend moved (if docked)
        const leftW = tcLeftEl ? tcLeftEl.getBoundingClientRect().width : 0;
        const rightW = tcRightEl ? tcRightEl.getBoundingClientRect().width : 0;
        const side = Math.max(leftW, rightW, 1);
        document.documentElement.style.setProperty("--sideW", side + "px");
      }

      function dockLegend() {
        if (isDocked) return;
        if (legendEl && tcRightEl) tcRightEl.prepend(legendEl);
        document.body.classList.add("legend-docked");
        isDocked = true;
        updateSideWidth();
      }

      function undockLegend() {
        if (!isDocked) return;
        if (legendEl && outHeadEl) outHeadEl.appendChild(legendEl);
        document.body.classList.remove("legend-docked");
        isDocked = false;
        updateSideWidth();
      }

      let raf = 0;
      function handleScroll() {
        if (raf) return;
        raf = requestAnimationFrame(() => {
          raf = 0;

          // Dock only when screen is wide enough that you want the top-right legend behavior.
          // If you want it for all widths, remove this condition.
          const wideEnough = window.innerWidth >= 989;

          // marker top relative to viewport
          const markerTop = marker.getBoundingClientRect().top;
          const topH = topControlsEl.getBoundingClientRect().height;

          // When marker goes under the sticky header => dock
          const shouldDock = wideEnough && markerTop <= topH + 1;

          if (shouldDock) dockLegend();
          else undockLegend();
        });
      }

      window.addEventListener("scroll", handleScroll, { passive: true });
      window.addEventListener("resize", () => {
        updateSideWidth();
        handleScroll();
      });

      // Observe size changes (wrap changes height/width)
      if ("ResizeObserver" in window) {
        const ro = new ResizeObserver(() => {
          updateSideWidth();
          handleScroll();
        });
        if (tcLeftEl) ro.observe(tcLeftEl);
        if (tcRightEl) ro.observe(tcRightEl);
        if (topControlsEl) ro.observe(topControlsEl);
      }

      // Initial run
      updateSideWidth();
      handleScroll();
    </script>
  </body>
</html>
